%YAML 1.2
---
# Sublime PML | Alpha | 2023/02/23 | PML 4.0.0
################################################################################
#                                                                              #
#                       PML (Practical Markup Language)                        #
#                                                                              #
#                              www.pml-lang.dev                                #
#                                                                              #
################################################################################
# PML syntax definition for Sublime Text 4, by Tristano Ajmone, MIT License:
#   https://github.com/tajmone/Sublime-PML
#
# The Practical Markup Language was created by Christian Neumanns:
#   https://github.com/pml-lang
# ------------------------------------------------------------------------------
name: PML (Practical Markup Language)
file_extensions:
  - pml
scope: text.pml
version: 2

variables:
  custom_id:  '[a-zA-Z_][a-zA-Z0-9_\-\.]*' # PML 3.1.0 (might change in the future!)
  pml_tag:    '[a-z][a-z_]*'       # PML tags are lowercase, no digits.
  nspace_tag: '[a-z][a-z_:]*\b'    # PML tags + namespace hack (temp workaround).
  pml_attr:   '[a-zA-Z][a-zA-Z_]*' # PML attributes are mixed-case, no digits.

contexts:
  prototype:
    - include: escapes_text
    - include: comment
    - include: parameter

  main:
    - include: pml_nodes

# ------------------------------------------------------------------------------

  ## Helpers
  ##########

  force-pop:
    - match: '(?=\S)'
      pop: true

  pop-at-EOL:
    - match: '(?=[\n$])'
      pop: true

  pop-at-TagEnd:
    - match: '(?=])'
      pop: true

  pop-at-ParensEnd:
    - match: '(?=\))'
      pop: true

  comsume-whitespace:
    - match: '[ \t]+'

  comsume-EOL:
    - match: '[\n$]'


# ==============================================================================
#                               Prototype Contexts
# ==============================================================================

  escapes_text:
    # Escape sequences allowed in normal text: \[ \] \\ \t \r \n \uhhhh
    - include: escapes_unicode
    - match: '\\[\[\]\\trn]'
      scope: constant.character.escape.pml

  parameter:
    - match: '(\[u:get) +({{custom_id}})(\])' # PML 2.3.0
      captures:
        0: meta.function-call.pml
        1: punctuation.definition.generic.begin.pml
        2: support.function.call.pml
        3: punctuation.definition.generic.end.pml

## Comment
##########

  comment:
    - match: '\[-'
      scope: punctuation.definition.comment.begin.pml
      push: comment_inside
  comment_inside:
    - meta_scope: comment.block.pml
    - meta_include_prototype: false
    - include: comment
    - match: '-]'
      scope: punctuation.definition.comment.end.pml
      pop: true

# ==============================================================================
#                               Misc. PML Elements
# ==============================================================================

## Escapes
##########

  escapes_unicode:
    # Hex digits are case insensitive!
    - match: '\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8}'
      scope: constant.character.escape.pml

  # @TODO: Quoted attributes escapes! also include: \"

# ******************************************************************************
# *                                                                            *
# *                                 PML Nodes                                  *
# *                                                                            *
# ******************************************************************************

  pml_nodes:
    - match: '(?=\[)'
      push: maybe_node

  maybe_node:
    - include: block_nodes
    - include: inline_nodes
    - include: text_processing_nodes
    - include: unknown_node
    # TODO: When all nodes are implemented, all that's left is an
    #       unescaped '[', which should be scoped as invalid/error!
    - include: force-pop

  unknown_node:
    # This is a just a temporary scope, to cover unimplemented native nodes.
    # Once all nodes are implemented it will be used to cover user-defined
    # nodes, but until all native nodes are supported we can't differentiate
    # between unimplemented nodes and user nodes.

    # @NOTE: The '{{nspace_tag}}' variable is a variation of '{{pml_tag}}' to
    #        capture tags w/ namespace! A temporary hack until namespaces are
    #        properly handled in the syntax definition.
    # @NOTE: We uses '{{nspace_tag/pml_tag}}' instead of '{{custom_id}}' because
    #        we want to match PML native nodes unsupported by the syntax, not
    #        user-defined nodes. (see 'variables:' at file start)
    # @TODO: Once all PML nodes are supported, replace '{{pml_tag}}' with
    #        '{{custom_id}}' and capture as user-defined node instead!

    - match: '\[{{nspace_tag}}\b' # namespace hack (replaces '{{pml_tag}}')
      scope: entity.name.tag.unknown.begin.pml
      push: [unknown_node_inside, unknown_node_attributes]
  unknown_node_inside:
    - meta_content_scope: entity.name.tag.unknown.contents.pml
    - match: ']'
      scope: entity.name.tag.unknown.end.pml
      pop: true
    - include: pml_nodes
  unknown_node_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: unknown_node_attributes_inside
    - match: '\s'
    - include: force-pop
  unknown_node_attributes_inside:
    - meta_content_scope: meta.group.node-attributes.unknown.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown


# ==============================================================================
#                                  Block Nodes
# ==============================================================================
# Every block-node opening and closing tags are scoped as:
#   - entity.name.tag.block-node.<NODE_NAME>.begin
#   - entity.name.tag.block-node.<NODE_NAME>.end
# except for raw-text blocks, which are given an extra `.raw` segment:
#   - entity.name.tag.block-node.raw.<NODE_NAME>.begin
#   - entity.name.tag.block-node.raw.<NODE_NAME>.end
# This consistent scope naming allows to easily target all nodes of a certain
# category via scope selectors (e.g. in colour schemes, completions, etc.).
# ------------------------------------------------------------------------------

# TODO: Sort `include:` statements by nodes' usage frequency. This should
#       improve performance, since each match resets the context loop.

  block_nodes:
    - include: doc         # Document
    - include: options     # Options
    - include: chapter     # Chapter | Has Default
    - include: html        # HTML Code | Raw + Childless
    - include: quote       # Quote
    - include: sourcecode  # Source Code Block
    - include: generic_block_node  # Matches unimplemented block-nodes
    # admonition        # Admonition
    # audio             # Audio (Sound) | Childless
    # caption           # Caption
    # constant          # Constant Parameter
    # division          # Division
    # fnotes            # Footnotes Placeholder
    # fnote_def         # Footnote Definition
    # header            # Header
    # image             # Image | Has Default + Childless
    # input             # Input | Raw + Childless
    # insert            # Insert File
    # insert_code       # Insert Source Code | Childless
    # list              # List
    # list_element      # List Element
    # monospace         # Monospace
    # note              # Note
    # output            # Output | Raw + Childless
    # paragraph         # Paragraph
    # table             # Table
    # table_cell        # Table Cell
    # table_data        # Table Data | Raw + Childless
    # table_footer      # Table Footer
    # table_header      # Table Header
    # table_row         # Table Row
    # video             # Video | Childless
    # youtube_video     # Embedded YouTube Video | Childless


## Generic Block Nodes
######################

# A temporary scope to match block nodes which are yet to
# be properly implemented.

  generic_block_node:
    - match: '(?x:
        \[
          (admon|audio|caption|div|el|fnote_def|fnotes|header|image
          |input|insert_code|list|monospace|note|output|p|table
          |table_data|tc|tfooter|theader|tr|video|youtube_video
          )\b)'
      scope: entity.name.tag.block-node.generic.begin.pml
      push: [generic_block_node_indise, generic_block_attributes]

  generic_block_node_indise:
    - include: pml_nodes
    - match: ']'
      scope: entity.name.tag.block-node.generic.end.pml
      pop: true

  generic_block_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: generic_block_attributes_inside
    - match: '\s'
    - include: force-pop
  generic_block_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.generic.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown


## Document
###########

# Attributes (none required, no default, no lenient parsing):
# - [x] ID
# - [x] HTML attributes: allowed

  doc:
    - match: '\[doc\b'
      scope: entity.name.tag.block-node.document.begin.pml
      # push: [doc_block, doc_title]
      push: [doc_block, title, doc_attributes]

  doc_block:
    - meta_scope: meta.block.document.pml
    - include: pml_nodes
    - match: ']'
      scope: entity.name.tag.block-node.document.end.pml
      pop: true

  doc_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: doc_attributes_inside
    - match: '\s'
    - include: force-pop
  doc_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.document.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?
    # @TODO: include unsupported attributes (as invalid):


## Options
###########

# @NOTE: Need to ensure that comments and constants are correctly
#        handled within options values (not marked as invalid).

# @TODO: Since PML 4, options *must* precede the [doc node!
#        I should enforce parsing [options only at doc start,
#        and scope as invalid any occurrences within the [doc tree.

  options:
    - match: '\[options\b'
      scope: entity.name.tag.block-node.options.begin.pml
      push: options_block
  options_block:
    - meta_content_scope: meta.block.options.pml
    - include: option_highlighter
    - include: option_toc_level
    - include: option_toc_position
    - include: option_toc_title
    - include: option_wrong_casing # catch bad letter casing
    - include: option_unknown      # generic fallback catcher
    - match: ']'
      scope: entity.name.tag.block-node.options.end.pml
      pop: true

  option_unknown:
    - match: '\[[a-zA-Z_]+\b'
      scope: entity.name.tag.option-node.unknown.begin.pml
      push:
      - meta_content_scope: meta.annotation.option.unknown.pml
      - match: ']'
        scope: entity.name.tag.option-node.unknown.end.pml
        pop: true
  option_wrong_casing:
    - match: '\[(?i:TOC_MAX_LEVEL|TOC_POSITION|TOC_TITLE|HIGHLIGHTER)\b'
      scope: invalid.option-node.begin.pml
      push:
      - match: ']'
        scope: invalid.option-node.end.pml
        pop: true

  option_highlighter:
    - match: '\[highlighter\b'
      scope: entity.name.tag.option-node.highlighter.begin.pml
      push:
      - meta_content_scope: meta.annotation.option.highlighter.pml
      - match: '(?i:highlightjs|prism|none)'
        scope: string.unquoted.pml
      - match: '[\w_\-]+'
        scope: invalid.option-value.pml
      - match: ']'
        scope: entity.name.tag.option-node.highlighter.end.pml
        pop: true

  option_toc_level:
    - match: '\[TOC_max_level\b'
      scope: entity.name.tag.option-node.toc-level.begin.pml
      push:
      - meta_content_scope: meta.annotation.option.toc-level.pml
      - match: '[^\d\s\]]+'
        scope: invalid.option-value.pml
      - match: ']'
        scope: entity.name.tag.option-node.toc-level.end.pml
        pop: true
  option_toc_position:
    - match: '\[TOC_position\b'
      scope: entity.name.tag.option-node.toc-position.begin.pml
      push:
      - meta_content_scope: meta.annotation.option.toc-position.pml
      - match: '(?i:left|top|none)'
        scope: string.unquoted.pml
      - match: '[\w_\-]+'
        scope: invalid.option-value.pml
      - match: ']'
        scope: entity.name.tag.option-node.toc-position.end.pml
        pop: true
  option_toc_title:
    - match: '\[TOC_title\b'
      scope: entity.name.tag.option-node.toc-title.begin.pml
      push:
      - meta_content_scope: meta.annotation.option.toc-title.pml
      - match: ']'
        scope: entity.name.tag.option-node.toc-title.end.pml
        pop: true


## Chapter
##########

# Attributes (none required, no default, no lenient parsing):
# - [x] id
# - [x] HTML attributes: allowed

  chapter:
    - match: '\[ch\b'
      scope: entity.name.tag.block-node.chapter.begin.pml
      push: [chapter_block, title, chapter_attributes]

  chapter_block:
    - meta_scope: meta.block.chapter.pml
    - include: pml_nodes
    - match: ']'
      scope: entity.name.tag.block-node.chapter.end.pml
      pop: true

  chapter_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: chapter_attributes_inside
    - match: '\s'
    - include: force-pop
  chapter_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.chapter.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?
    # @TODO: include unsupported attributes (as invalid):


## Title
##########

# Attributes (none required, no default, no lenient parsing):
# - [x] id
# - [x] HTML attributes: allowed

  title:
    - match: '\[title\b(?:[ \t]+)*'
      scope: entity.name.tag.block-node.title.begin.pml
      push: [title_inside, title_attributes]
    - include: force-pop
  title_inside:
    - meta_scope: meta.block.title.pml
    - meta_content_scope: meta.toc-list.heading.pml
    - match: ']'
      scope: entity.name.tag.block-node.title.end.pml
      pop: 2
    - match: '^[ \t]+'          # consume leading space
    - match: '[ \t]+(?=[\]$])'  # consume trailing space
    - include: inline_nodes
    - include: text_processing_nodes
    - include: unknown_node
    - match: '.'
      scope: markup.heading.pml meta.toc-list.heading.pml

  title_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: title_attributes_inside
    - match: '\s'
    - include: force-pop
  title_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.title.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?
    # @TODO: include unsupported attributes (as invalid):


## Quote
########

# Attributes (none required, no default, no lenient parsing):
# - [x] id
# - [x] HTML attributes: allowed

  # Only actual node-contents are scoped as 'markup.quote' and whitespace
  # surrounding the opening and closing tags is skipped as far as possible,
  # just as the PML parser does. This results in better visual highlighting.

  quote:
    - match: '\[quote\b'
      scope: entity.name.tag.block-node.quote.begin.pml
      push: [quote_block, quote_attributes]

  quote_block:
    - match: '\s*' # Consume leading WS
    - match: '(?!\s)'
      set:
      - meta_content_scope: markup.quote.pml
      - include: qsource
      - include: pml_nodes
      - match: '(?:\s*)]' # Consume trailing WS before closing bracket
        scope: entity.name.tag.block-node.quote.end.pml
        pop: true

  quote_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: quote_attributes_inside
    - match: '\s'
    - include: force-pop
  quote_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.quote.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?
    # @TODO: include unsupported attributes (as invalid):


  ## Quote Source
  ###############

  # Attributes (none required, no default, no lenient parsing):
  # - [x] id
  # - [x] HTML attributes: allowed

  qsource:
  - match: '\[qsource\b'
    scope: entity.name.tag.block-node.quote-source.begin.pml
    push: [qsource_block, quote_attributes]

  qsource_block:
    - meta_content_scope: meta.block.quote-source.pml
    - include: pml_nodes
    - match: '\]'
      scope: entity.name.tag.block-node.quote-source.end.pml
      pop: true

  qsource_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: qsource_attributes_inside
    - match: '\s'
    - include: force-pop
  qsource_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.quote-source.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?

############################
##  RAW-TEXT BLOCK NODES  ##
############################----------------------------------------------------
# This group of block-nodes contain 'raw text', i.e. their contents are not
# processed by PMLC, which means that they can't contain any PML nodes inside,
# and their tag name is repeated in the closing node delimiter (see #24).
# For this reason, they are scoped with an extra `.raw` segment:
#   - entity.name.tag.block-node.raw.<NODE_NAME>.begin
#   - entity.name.tag.block-node.raw.<NODE_NAME>.end
# in order to simplify targeting them via scope selectors.
# ------------------------------------------------------------------------------


## HTML
#######

# Attributes (none required, no default, unconstrained attributes lenient parsing):
# - [x] id
# - [x] HTML attributes: allowed

  # @TODO: Implement unconstrained attributes lenient parsing.

  # NOTE: The contexts here are a bit hackish and require some redundancy
  #       in order to correctly handle optional attributes.

  html:
    - match: '\[html\b'
      scope: entity.name.tag.block-node.raw.html.begin.pml
      push: [html_contents_end, html_attributes_or_delimiter]
  html_attributes_or_delimiter:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: html_attributes_inside
    - match: '^(?=( |\t)*["=~]{3,})'
      set: html_contents
  html_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.html.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      set: html_contents
    - include: attr_id
    - include: attr_html
    - include: attr_unknown # @NOTE: To cover future new attributes?
  html_contents:
    - match: '^(( |\t)*["=~]{3,})$\n?'
      scope: meta.code-fence.definition.begin.pml punctuation.definition.raw.code-fence.begin.pml
      set: Packages/HTML/HTML.sublime-syntax
      with_prototype:
        - match: ^\1$\n?
          scope: meta.code-fence.definition.end.pml punctuation.definition.raw.code-fence.end.pml
          pop: true
  html_contents_end:
    - match: '\]'
      scope: entity.name.tag.block-node.raw.html.end.pml
      pop: true


## Source Code Block
####################

# Attributes (none required, no default, unconstrained attributes lenient parsing):
# - [x] id
# - [ ] highlight = [yes|no]
# - [ ] lang
# - [x] HTML attributes: allowed

  # @TODO: Implement missing attributes.
  # @TODO: Implement unconstrained attributes lenient parsing.

  sourcecode:
    - match: '\[code\b'
      scope: entity.name.tag.block-node.raw.listing.begin.pml
      push: [sourcecode_block, sourcecode_attributes]
  sourcecode_block:
    - meta_scope: meta.embedded.block.listing.pml
    - match: ''
      set:
      - meta_content_scope: source.block.listing.content.pml
                            meta.embedded.block.listing.pml
      - match: '\bcode]'
        scope:  entity.name.tag.block-node.raw.listing.end.pml
                meta.embedded.block.listing.pml
        pop: true
  sourcecode_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: sourcecode_attributes_inside
    - match: '\s'
    - include: force-pop
  sourcecode_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.listing.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_id
    - include: attr_html
    # @TODO: include remaining supported attributes:
    - include: attr_unknown # @NOTE: To cover future new attributes?
    # @TODO: include unsupported attributes (as invalid):


# ==============================================================================
#                                  Inline Nodes
# ==============================================================================
# Every inline-node opening and closing tags are scoped as:
#   - entity.name.tag.inline-node.<NODE_NAME>.begin
#   - entity.name.tag.inline-node.<NODE_NAME>.end
# This consistent scope naming allows to easily target all nodes of a certain
# category via scope selectors (e.g. in colour schemes, completions, etc.).
# ------------------------------------------------------------------------------

  inline_nodes:
    - include: bold         # Bold Text
    - include: italic       # Italic Text
    - include: code         # Inline Source Code
    - include: newline      # New Line (<br>)
    - include: space        # Non-Breaking Space (&nbsp;)
    - include: span         # Span
    - include: subscript    # Subscript Text
    - include: superscript  # Superscript Text
    - include: strike       # Strikethrough Text
    - include: generic_inline_node # Matches unimplemented inline-nodes
    # fnote                 # Inline Footnote
    # fnote_ref             # Footnote Reference
    # link                  # URL Link
    # text                  # Text
    # verbatim              # Verbatim Text
    # xref                  # Cross-Reference

## Generic Inline Nodes
######################

# A temporary scope to match inline nodes which are yet to
# be properly implemented.

  generic_inline_node:
    - match: '(\[(fnote|fnote_ref|link|text|verbatim|xref)\b)'
      scope: entity.name.tag.inline-node.generic.begin.pml
      push: [generic_inline_node_indise, generic_inline_attributes]

  generic_inline_node_indise:
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.generic.end.pml
      pop: true

  generic_inline_attributes:
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: generic_inline_attributes_inside
    - match: '\s'
    - include: force-pop
  generic_inline_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.generic.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_html
    - include: attr_unknown


## Font: Bold Text
##################

  bold:
    - match: '\[b\b'
      scope: entity.name.tag.inline-node.bold.begin.pml
      push: bold_inside
  bold_inside:
    - meta_scope: markup.bold.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.bold.end.pml
      pop: true

## Font: Italic Text
####################

  italic:
    - match: '\[i\b'
      scope: entity.name.tag.inline-node.italic.begin.pml
      push: italic_inside
  italic_inside:
    - meta_scope: markup.italic.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.italic.end.pml
      pop: true

## Font: Subscript Text
#######################

  subscript:
    - match: '\[sub\b'
      scope: entity.name.tag.inline-node.subscript.begin.pml
      push: subscript_inside
  subscript_inside:
    - meta_scope: markup.subscript.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.subscript.end.pml
      pop: true

## Font: Superscript Text
#########################

  superscript:
    - match: '\[sup\b'
      scope: entity.name.tag.inline-node.superscript.begin.pml
      push: superscript_inside
  superscript_inside:
    - meta_scope: markup.superscript.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.superscript.end.pml
      pop: true

## Font: Strikethrough Text
###########################

  strike:
    - match: '\[strike\b'
      scope: entity.name.tag.inline-node.strikethrough.begin.pml
      push: strike_inside
  strike_inside:
    - meta_scope: markup.strikethrough.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.strikethrough.end.pml
      pop: true

## Font: Inline Source Code
###########################

  # Unlike `[b` and `[i`, the contents of `[c` need to be scoped to allow
  # proper styling. We also need to mimic how PMLC trims trailing spaces,
  # including when contents are spread across multiple indented lines.

  code:
    - match: '\[c\b(?:[ \t\n]*)'
      scope: entity.name.tag.inline-node.code.begin.pml
      push: code_inside
  code_inside:
    - meta_scope: markup.raw.inline.pml
    - match: '^[ \t]+'  # Consume leading WS != markup.raw.inline.content
    - include: inline_nodes
    - match: ']' # @CHECK: Should trailing WS be consumed too?
      scope: entity.name.tag.inline-node.code.end.pml
      pop: true
    - match: '.'
      scope: markup.raw.inline.content.pml


## Span
#######

  # @TODO: Supports HTML Attributes (only).

  span:
    - match: '\[span\b'
      scope: entity.name.tag.inline-node.span.begin.pml
      push: span_inside
  span_inside:
    - meta_scope: markup.span.pml
    - include: inline_nodes
    - match: ']'
      scope: entity.name.tag.inline-node.span.end.pml
      pop: true

## New Line and Space
#####################

  newline:
    - match: '\[nl\b'
      scope: entity.name.tag.inline-node.newline.begin.pml
      push: newline_inside
  newline_inside:
    - meta_scope: meta.inline-node.newline.pml
    - meta_include_prototype: false
    - include: comment
    - include: comsume-whitespace
    - include: comsume-EOL
    - match: ']'
      scope: entity.name.tag.inline-node.newline.end.pml
      pop: true
    # Match any tags as invalid:
    - match: '\['
      scope: invalid.illegal.pml
      push:
      - match: ']'
        scope: invalid.illegal.pml
        pop: true
      - match: '.'
        scope: invalid.illegal.pml
    # Match any text contents as invalid:
    - match: '.'
      scope: invalid.illegal.pml

  space:
    - match: '\[sp\b'
      scope: entity.name.tag.inline-node.nbsp.begin.pml
      push: space_inside
  space_inside:
    - meta_scope: meta.inline-node.nbsp.pml
    - meta_include_prototype: false
    - include: comment
    - include: comsume-whitespace
    - include: comsume-EOL
    - match: ']'
      scope: entity.name.tag.inline-node.nbsp.end.pml
      pop: true
    - match: '.'
      scope: invalid.illegal.pml

# ==============================================================================
#                             Text Processing Nodes
# ==============================================================================

  text_processing_nodes:
    - include: constant   # Constant Parameter
    # u:ins_file          # Insert File
    # comment [-> prototype]

## Constant Parameter
#####################

# @TODO: Support multiple definitions at once.
# @TODO: Unquoted value: no escapes!
# @TODO: Quoted string value: use attribute specific escapes!

  constant:
    - match: '\[u:set\b' # PML 2.3.0
      scope: entity.name.tag.inline-node.constant.begin.pml
      push: constant_inside
  constant_inside:
    - meta_scope: meta.tag.constant.pml
    - match: ']'
      scope: entity.name.tag.inline-node.constant.end.pml
      pop: true
    - match: '\b{{custom_id}}\b'
      scope: entity.name.function.pml
    - match: '='
      scope: keyword.operator.assignment.pml
      set: constant_value
  constant_value:
    - meta_scope: meta.tag.constant.pml
    - match: ']'
      scope: entity.name.tag.inline-node.constant.end.pml
      pop: true
    - include: string
    - include: force-pop

# ******************************************************************************
# *                                                                            *
# *                               PML Attributes                               *
# *                                                                            *
# ******************************************************************************

  # Shared '()' Attributes-Group Parsing:
  dummy_attributes:
    # USED-BY: **none at the moment!**.
    # Temporary workaround shared by multiple nodes. Allows to quickly implement
    # nodes in bulk without having to deal with node-specific attributes
    # grouping within '()'. It will be deleted once each node has it's own
    # attributes capturing context.
    - match: '\('
      scope: punctuation.section.group.begin.pml
      set: dummy_attributes_inside
    - match: '\s'
    - include: force-pop
  dummy_attributes_inside:
    - meta_scope: meta.annotation.node-attributes.generic.pml
    - match: '\)'
      scope: punctuation.section.group.end.pml
      pop: true
    - include: attr_unknown # Catch any attributes as 'unknown'


  attr_unknown:
    # This is a just a temporary scope, to cover unimplemented attributes.
    # It will be removed once all nodes and attributes are implemented.
    - match: ']'
      scope: entity.name.tag.unknown.end.pml
      pop: true
    - match: '\b({{pml_attr}}) *(=)'
      captures:
        1: entity.other.attribute-name.unknown.pml
        2: keyword.operator.assignment.pml


  attr_id:
    - match: '\b(id)\b'
      scope: entity.other.attribute-name.id.pml
      push:
        - match: '='
          scope: keyword.operator.assignment.pml
          set:
            - include: pop-at-ParensEnd
            - include: id_type


  attr_html:
    - match: '\b(html_[a-z]{2}[a-z-]*)\b'
      scope: entity.other.attribute-name.html.pml
      push:
        - include: pop-at-ParensEnd
        - match: '='
          scope: keyword.operator.assignment.pml
          set:
            - include: pop-at-ParensEnd
            - match: '"'
              scope: punctuation.definition.string.begin.pml
              set:
                # TODO: Should stop using prototypes inside string?
                - meta_scope: string.quoted.double.pml
                - include: string_quoted_escapes
                - match: '"'
                  scope: punctuation.definition.string.end.pml
                  pop: true
            - include: attr_html_unquoted
  attr_html_unquoted:
    # We can't use the 'string_unquoted' context here because we need to pop
    # when a ')' is encountered.
    - match: '(?! )'
      push:
        - meta_scope: string.unquoted.pml
        - match: '(?=\s*\))' # Don't consume/scope trailing spaces before ')'
          pop: true


# ******************************************************************************
# *                                                                            *
# *                                 PML Types                                  *
# *                                                                            *
# ******************************************************************************

# Attributes' and tags' values can be of various types:
#   - [x] String double-quoted
#   - [x] String without quotes
#   - [x] Date
#   - [x] Time
#   - [x] ID
#   - [ ] URL
#   - [ ] File (absolute/relative)
#   - [ ] ... others??? ...


  id_type:
    - include: id_quoted
    - include: id_unquoted
  id_quoted:
    - match: '""'
      scope: invalid.illegal.id.pml
    - match: '(")(\s+)(")'
      captures:
        1: punctuation.definition.string.begin.pml
        2: invalid.illegal.id.pml
        3: punctuation.definition.string.end.pml
    - match: '"'
      scope: punctuation.definition.string.begin.pml
      set:
      - match: '({{custom_id}})(")'
        captures:
          1: string.quoted.id.pml meta.toc-list.id.pml
          2: punctuation.definition.string.end.pml
        pop: true
      - match: '([^"]+)(")'
        captures:
          1: invalid.illegal.id.pml
          2: punctuation.definition.string.end.pml
        pop: true
      # Handle lack of string terminator:
      - match: '.*'
        scope: invalid.illegal.id.pml
        pop: true
  id_unquoted:
    - match: '\b({{custom_id}})\b(?![\.\-])'
      scope: string.unquoted.id.pml meta.toc-list.id.pml
      pop: true
    - match: '([^\s\)]+)' # don't capture ')' in case we're in attributes group
      scope: invalid.illegal.id.pml
      pop: true
      # See pml-lang/user-manual/discussions/3


  string:
    - include: string_quoted   # must always precede `string_unquoted`
    - include: string_unquoted
    - include: force-pop
  string_quoted:
    - match: '"'
      scope: punctuation.definition.string.begin.pml
      push: string_quoted_inside
  string_quoted_inside:
    # TODO: Should stop using prototypes inside string?
    - meta_scope: string.quoted.double.pml
    - include: string_quoted_escapes
    - match: '"'
      scope: punctuation.definition.string.end.pml
      pop: true
  string_quoted_escapes:
    - match: '\\"'
      scope: constant.character.escape.pml
  string_unquoted:
    - match: '(?! )'
      push:
        - meta_scope: string.unquoted.pml
        - match: '(?=\s+)$'
          pop: true
        - match: '(?=\s*\])'
          pop: true

# EOF #
